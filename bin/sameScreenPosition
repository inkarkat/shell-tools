#!/bin/bash

: ${RESTORE_CURSOR_POSITION=[u}
: ${SAVE_CURSOR_POSITION=[s}
: ${ERASE_TO_END=[0J}

printUsage()
{
    cat <<HELPTEXT
Clear the remainder of the screen, execute COMMAND and return the cursor to the
original position, so that a subsequent invocation will overwrite the COMMAND's
output (as long as no scrolling happens). If you don't use --last for the final
invocation, the last COMMAND's output will be overwritten by a shell prompt.
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '-c|--command "COMMANDLINE" [-c ...] | [--] SIMPLECOMMAND [...] [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '--last -c|--command "COMMANDLINE" [-c ...] | [--] SIMPLECOMMAND [...] [-?|-h|--help]'
    echo
    cat <<HELPTEXT
Execute COMMAND and on --subsequent invocations return the cursor to the
original position and clear to the end, so that these overwrite the COMMAND's
output (as long as no scrolling happens).
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '--first [-l|--max-length COLS] -c|--command "COMMANDLINE" [-c ...] | [--] SIMPLECOMMAND [...] [-?|-h|--help]'
    printf 'Usage: %q %s\n' "$(basename "$1")" '--subsequent [-l|--max-length COLS] -c|--command "COMMANDLINE" [-c ...] | [--] SIMPLECOMMAND [...] [-?|-h|--help]'
}

before="${SAVE_CURSOR_POSITION}${ERASE_TO_END}"
after="$RESTORE_CURSOR_POSITION"
isNeedEval=
typeset -a commands=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--first)	shift; after='';;
	--subsequent)	shift; before="${RESTORE_CURSOR_POSITION}${ERASE_TO_END}"; after='';;
	--last)		shift; after='';;
	--command|-c)	shift; commands+=(${commands:+;} "$1"); isNeedEval=t; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -ne 0 ]; then
    if [ "$isNeedEval" ]; then
	# Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
	# undo the effects of eval.
	printf -v quotedSimpleCommand '%q ' "$@"
	commands+=(${commands:+;} "${quotedSimpleCommand% }")
    else
	commands=("$@")
    fi
fi
if [ ${#commands[@]} -eq 0 ]; then
    echo 'ERROR: No COMMAND(s) specified; need to pass -c|--command "COMMANDLINE", or SIMPLECOMMAND.'
    echo
    printUsage "$0"
    exit 2
fi >&2

[ -z "$before" ] || printf >/dev/tty %s "$before"
[ -z "$after" ] || trap 'printf >/dev/tty %s "$after"' INT QUIT EXIT

if [ "$isNeedEval" ]; then
    eval "${commands[@]}"
else
    "${commands[@]}"
fi
