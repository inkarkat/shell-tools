#!/bin/bash
set -o pipefail

: ${WITHSELECTEDFILES_DEFAULT_COMMAND='printf %s\\n'}
: ${WITHSELECTEDFILES_COMMAND_JOINER=;}
: ${WITHSELECTEDFILES_EXEC_END=;}
: ${WITHSELECTEDFILES_FILES_END=;}
: ${WITHSELECTEDFILES_FILE_MARKER='{}'}
fileMarker="$WITHSELECTEDFILES_FILE_MARKER"; unset WITHSELECTEDFILES_FILE_MARKER
: ${WITHSELECTEDFILES_SELECTED_EXEC_END=;}
: ${WITHSELECTEDFILES_SELECTED_FILE_MARKER='{}'}
selectFileMarker="$WITHSELECTEDFILES_SELECTED_FILE_MARKER"; unset WITHSELECTEDFILES_SELECTED_FILE_MARKER

printShortUsage()
{
    local commonArgs="--generator-command \"GENERATOR-COMMANDLINE\" [--generator-command ...] | --generator-exec GENERATOR-SIMPLECOMMAND [...] ${WITHSELECTEDFILES_SELECTED_EXEC_END} [--generator-exec ...] | --select-command \"SELECT-COMMANDLINE\" [--select-command ...] | --select-exec SELECT-SIMPLECOMMAND [...] ${WITHSELECTEDFILES_SELECTED_EXEC_END} [--select-exec ...] -c|--command \"COMMANDLINE\" [-c ...] | --exec SIMPLECOMMAND [...] ${WITHSELECTEDFILES_EXEC_END} [--exec ...] | SIMPLECOMMAND [...]"
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" "${commonArgs} [--] FILE [...] [-?|-h|--help]"
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" "-f|--files [FILE ...] ${WITHSELECTEDFILES_FILES_END} [-f ...] ${commonArgs} [-?|-h|--help]"
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Execute COMMAND on / print the file(s) (which ${fileMarker:+either }are appended${fileMarker:+ or replace any
$fileMarker marker} inside COMMANDLINE) that are generated by GENERATOR-COMMAND or
selected by SELECT-COMMAND. Any passed FILE(s) ${selectFileMarker:+either }are appended${selectFileMarker:+ or replace
any $selectFileMarker marker} inside SELECT-COMMAND.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --exec CMD [...] ${WITHSELECTEDFILES_EXEC_END}	Execute CMD; all following arguments are taken to be
			arguments to the CMD until an argument consisting of
			'${WITHSELECTEDFILES_EXEC_END}' is encountered.
    --files|-f FILE [...] ${WITHSELECTEDFILES_FILES_END}
			Take FILE(s) separately, don't parse FILE(s) at the end;
			all arguments there belong to SIMPLECOMMAND.

FILE(s) are mandatory if only SELECT-COMMAND is provided; if only
GENERATOR-COMMAND is provided, all trailing arguments (even those after --) are
simply added to SIMPLECOMMAND, and the --files parameter is forbidden.
If both are provided, FILE(s) are parsed; if none are given then
GENERATOR-COMMAND is executed.

SEE ALSO:
- withFirstExistingFile only passes the first existing file to COMMAND.
- eachFile executes COMMAND on each FILE individually, not just on the first.

EXIT STATUS:
    2	Bad invocation, wrong or missing command-line arguments.
    3	Internal error or failed assertion.
    4	No files have been generated by GENERATOR-COMMAND / selected by
	SELECT-COMMAND.
    *   any exit status from COMMAND(s)
HELPTEXT
}

generatorCommands=
selectCommands=
typeset -a filespecs=()
commands=
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--files|-f)	shift
			while [ $# -gt 0 -a "$1" != "$WITHSELECTEDFILES_FILES_END" ]
			do
			    filespecs+=("$1")
			    shift
			done
			if [ $# -eq 0 ]; then
			    echo "ERROR: --files|-f must be concluded with '${WITHSELECTEDFILES_FILES_END}'"; echo; printUsage "$0"
			    exit 2
			fi >&2
			shift
			if [ -z "$generatorCommands" -a ${#filespecs[@]} -eq 0 ]; then
			    echo 'ERROR: --files|-f must be followed by at least one FILE.'; echo; printUsage "$0"
			    exit 2
			fi >&2
			;;

	--select-exec)	shift
			cmd=
			printf -v escapedPassedFileMarker %q "$selectFileMarker"
			while [ $# -gt 0 -a "$1" != "$WITHSELECTEDFILES_SELECTED_EXEC_END" ]
			do
			    printf -v quotedArg '%q' "$1"
			    cmd="${cmd}${cmd:+ }${quotedArg//"$escapedPassedFileMarker"/$selectFileMarker}"	# %q escapes {}, we don't want that to have it interpolated later.
			    shift
			done
			if [ $# -eq 0 ]; then
			    echo "ERROR: --select-exec command must be concluded with '${WITHSELECTEDFILES_SELECTED_EXEC_END}'"; echo; printUsage "$0"
			    exit 2
			fi >&2
			shift
			selectCommands+="${selectCommands:+ ; }${cmd}"
			;;
	--select-command)
			shift; selectCommands+="${selectCommands:+ ; }$1"; shift;;

	--generator-exec)
			shift
			cmd=
			while [ $# -gt 0 -a "$1" != "$WITHSELECTEDFILES_SELECTED_EXEC_END" ]
			do
			    printf -v quotedArg '%q' "$1"
			    cmd="${cmd}${cmd:+ }${quotedArg}"
			    shift
			done
			if [ $# -eq 0 ]; then
			    echo "ERROR: --generator-exec command must be concluded with '${WITHSELECTEDFILES_SELECTED_EXEC_END}'"; echo; printUsage "$0"
			    exit 2
			fi >&2
			shift
			generatorCommands+="${generatorCommands:+ ; }${cmd}"
			;;
	--generator-command)
			shift; commands+="${generatorCommands:+ $WITHSELECTEDFILES_COMMAND_JOINER }$1"; shift;;

	--exec)		shift
			cmd=
			printf -v escapedFileMarker %q "$fileMarker"
			while [ $# -gt 0 -a "$1" != "$WITHSELECTEDFILES_EXEC_END" ]
			do
			    printf -v quotedArg '%q' "$1"
			    cmd="${cmd}${cmd:+ }${quotedArg//"$escapedFileMarker"/$fileMarker}"	# %q escapes {}, we don't want that to have it interpolated later.
			    shift
			done
			if [ $# -eq 0 ]; then
			    echo "ERROR: --exec command must be concluded with '${WITHSELECTEDFILES_EXEC_END}'"; echo; printUsage "$0"
			    exit 2
			fi >&2
			shift
			commands+="${commands:+ $WITHSELECTEDFILES_COMMAND_JOINER }${cmd}"
			;;
	--command|-c)	shift; commands+="${commands:+ $WITHSELECTEDFILES_COMMAND_JOINER }$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		typeset -a files=()
			if [ ${#filespecs[@]} -eq 0 -a -n "$selectCommands" ] && ! contains -- "$@"; then
			    while [ $# -gt 0 ]
			    do
				lastArg="${!#}"
				[ -e "$lastArg" ] || break
				files=("$lastArg" "${files[@]}")
				set -- "${@:1:$(($#-1))}"
			    done
			fi

			if [ $# -gt 0 ]; then
			    typeset -a cmd=()
			    while [ $# -gt 0 ] && [ ${#filespecs[@]} -gt 0 -o -z "$selectCommands" -o "$1" != -- ]  # Note: No stopping at -- if no SELECT-COMMAND or --files is used.
			    do
				cmd+=("$1")
				shift
			    done
			    # Combine --command and SIMPLECOMMAND; need to quote SIMPLECOMMAND to
			    # undo the effects of eval.
			    printf -v quotedSimpleCommand '%q ' "${cmd[@]}"
			    printf -v escapedFileMarker %q "$fileMarker"
			    commands+="${commands:+ $WITHSELECTEDFILES_COMMAND_JOINER }${quotedSimpleCommand//"$escapedFileMarker"/$fileMarker}"	# %q escapes {}, we don't want that to have it interpolated later.
			fi

			if [ ${#files[@]} -gt 0 ]; then
			    set -- "$@" "${files[@]}"
			    break
			fi
			;;
    esac
done
filespecs+=("$@")
if [ -z "$generatorCommands" -a -z "$selectCommands" ]; then
    echo "ERROR: No GENERATOR-COMMAND(s) nor SELECT-COMMAND(s) specified; need to pass --generator-command \"GENERATOR-COMMANDLINE\", or --generator-exec GENERATOR-SIMPLECOMMAND [...] ${WITHSELECTEDFILES_SELECTED_EXEC_END} and/or --select-command \"SELECT-COMMANDLINE\", or --select-exec SELECT-SIMPLECOMMAND [...] ${WITHSELECTEDFILES_SELECTED_EXEC_END}"
    echo
    printUsage "$0"
    exit 2
elif [ -z "${commands:=$WITHSELECTEDFILES_DEFAULT_COMMAND}" ]; then
    echo "ERROR: No COMMAND(s) specified; need to pass -c|--command \"COMMANDLINE\", or --exec SIMPLECOMMAND [...] ${WITHSELECTEDFILES_EXEC_END} or SIMPLECOMMAND."
    echo
    printUsage "$0"
    exit 2
elif [ -z "$generatorCommands" -a ${#filespecs[@]} -eq 0 ]; then
    echo 'ERROR: No FILE(s) passed.'
    echo
    printUsage "$0"
    exit 2
elif [ -z "$selectCommands" -a ${#filespecs[@]} -gt 0 ]; then
    echo 'ERROR: Passed FILE(s) are ignored by the GENERATOR-COMMAND, as no SELECT-COMMAND is provided.'
    echo
    printUsage "$0"
    exit 2
fi >&2

typeset -a s=()
if [ ${#filespecs[@]} -gt 0 ]; then
    printf -v quotedFiles '%q ' "${filespecs[@]}"; quotedFiles="${quotedFiles% }"
    s=("${filespecs[@]}")
    sourceCommands="${selectCommands//"$selectFileMarker"/$quotedFiles}"
    [ "$sourceCommands" = "$selectCommands" ] || s=()
else
    sourceCommands="$generatorCommands"
fi
readarray -t selectedFiles < <(eval "$sourceCommands" '"${s[@]}"')
if [ ${#selectedFiles[@]} -eq 0 ]; then
    exit 4
fi

printf -v quotedSelectedFiles '%q ' "${selectedFiles[@]}"; quotedSelectedFiles="${quotedSelectedFiles% }"
interpolatedCommands="${commands//"$fileMarker"/$quotedSelectedFiles}"
[ "$interpolatedCommands" = "$commands" ] || quotedSelectedFiles=''
eval "$interpolatedCommands" "$quotedSelectedFiles"
